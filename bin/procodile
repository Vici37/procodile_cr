#!/usr/bin/env ruby

trap("INT") { puts ; exit 1 }

$:.unshift(File.expand_path('../../lib', __FILE__))

require 'optparse'
require 'fileutils'
require 'yaml'
require 'procodile'
require 'procodile/version'
require 'procodile/error'
require 'procodile/config'
require 'procodile/cli'

Thread.abort_on_exception = true

command = ARGV[0] || 'help'
cli = Procodile::CLI.new

options = {}
begin
  OptionParser.new do |opts|
    opts.version = Procodile::VERSION
    opts.banner = "Usage: procodile #{command} [options]"
    opts.on("-r", "--root PATH", "The path to the root of your application") do |root|
      options[:root] = root
    end

    opts.on("-e", "--environment NAME", "The config environment to use") do |name|
      options[:environment] = name
    end

    opts.on("--procfile PATH", "The path to the Procfile (defaults to: Procfile)") do |path|
      options[:procfile] = path
    end

    if cli.class.commands[command.to_sym] && option_block = cli.class.commands[command.to_sym][:options]
      option_block.call(opts, cli)
    end
  end.parse!
rescue OptionParser::InvalidOption, OptionParser::MissingArgument => e
  $stderr.puts "Error: #{e.message}".color(31)
  exit 1
end

global_config = {}
if options[:root] && options[:procfile]
  # root and profile provided on the command line
  root = options[:root]
  procfile = options[:procfile]
elsif options[:root] && options[:procfile].nil?
  # root provided on the command line but no procfile
  root = options[:root]
  procfile = nil
elsif options[:root].nil? && options[:procfile]
  # no root provided but a procfile is provided
  procfile = File.expand_path(options[:procfile])
  root = File.dirname(procfile)
else
  # we don't really know what to do in this situation, if there's a global config
  #Â file we can use that
  global_config_path = ENV['PROCODILE_CONFIG'] || "/etc/procodile"
  if File.exist?(global_config_path)
    global_config = YAML.load_file(global_config_path)
    if global_config.is_a?(Array)
      puts "There are multiple applications configured in #{global_config_path}"
      if File.file?("Procfile")
        puts "\e[45;37mChoose an appplication or press ENTER to use the current directory:\e[0m"
      else
        puts "\e[45;37mChoose an application:\e[0m"
      end
      global_config.each_with_index do |app, i|
        col = i % 3
        print "#{(i+1)}) #{app['name']}"[0,28].ljust(col != 2 ? 30 : 0, ' ')
        if col == 2 || i == global_config.size - 1
          puts
        end
      end
      app_id = STDIN.gets.to_i
      if app_id == 0
        if File.file?('Procfile')
          puts "Skipping application selection... using current directory"
          global_config = {}
        else
          exit 1
        end
      elsif app = global_config[app_id - 1]
        puts "\e[35mYou selected #{app['name']}\e[0m"
        global_config = app
      else
        puts "Invalid app number"
        exit 1
      end
    end
  end
end

if global_config['user'] && ENV['USER'] != global_config['user']
  if global_config['user_reexec']
    $stderr.puts "\e[31mProcodile must be run as #{global_config['user']}. Re-executing as #{global_config['user']}...\e[0m"
    exec "sudo -u #{global_config['user']} -- #{$0} #{ARGV.join(' ')}"
  else
    $stderr.puts "\e[31mError: Procodile must be run as #{global_config['user']}\e[0m"
    exit 1
  end
end

if global_config['root'] && global_config['procfile']
  # the global config specifies a root and a procfile
  root = global_config['root']
  procfile = File.expand_path(global_config['procfile'], root)
elsif global_config['root'] && global_config['procfile'].nil?
  root = global_config['root']
  procfile = nil # assume from the root
elsif global_config['root'].nil? && global_config['procfile']
  procfile = global_config['procfile']
  root = File.dirname(procfile)
else
  root = FileUtils.pwd
  procfile = nil
end

begin
  if command != 'help'
    cli.config = Procodile::Config.new(root, options[:environment], procfile)
  end
  cli.dispatch(command)
rescue Procodile::Error => e
  $stderr.puts "Error: #{e.message}".color(31)
  exit 1
end
